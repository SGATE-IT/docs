# Certificate/Key

## System Public Key

The system public key assigned by the system to merchants, and each merchant corresponds to a different system public key.

## Merchant Public/Private Key

The public/private key generated by the merchant side needs to follow the agreed [public/private key algorithm](/en/virtualAccountApi/apiRule/certificateKey#public-private-key-algorithm) for generation rules, otherwise there may be a problem of signature verification failure.


## Public/Private Key Algorithm

* Key algorithm：`RSA`
  * JAVA ：`RSA`
  *  PHP ：`OPENSSL_KEYTYPE_RSA`

- Key byte：2048
- Key format：
  - JAVA :PKCS8 
  - Others: PKCS1 

* Sign algorithm：`MD5`
  *  JAVA ：`MD5withRSA`
  * PHP ：`OPENSSL_ALGO_MD5`

* Fill model：`OPENSSL_PKCS1_PADDING`

* Data exchange: Signature and encrypted data are transmitted using `Base64` encoding

**Example of generating public and private keys using the openssl command**

```shell
# Generate private key

openssl genrsa -out key.pem 2048

# Convert the private key to PKCS8 format, and use this as the private key in the future

openssl pkcs8 -topk8 -inform PEM -in key.pem -outform PEM -nocrypt

# Generate public key

openssl rsa -in key.pem -pubout -out public.pem
```

**Demo**

::: details Click to view code examples
::: code-group

```java [JAVA]
/// ...
/**
 * Private key signing
 * @param data Original data
 * @param privateKey private key
 * @return Encrypted data
 * @throws Exception
 */
static String sign(String data, String privateKey) throws Exception {
byte[] keyBytes = Base64.decode(privateKey);
PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);

KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
PrivateKey privateK   = keyFactory.generatePrivate(pkcs8KeySpec);
Signature signature   = Signature.getInstance(SIGNATURE_ALGORITHM);

signature.initSign(privateK);
signature.update(data.getBytes(ENCODING));
return Base64.encodeToString(signature.sign());
}

/**
 * Public key verification
 * @param data Original data
 * @param publicKey public Key
 * @param sign data signature
 * @return Verification results
 * @throws Exception
 */
static boolean verifySign(String data, String publicKey, String sign) throws Exception {
try {
    byte[] keyBytes = Base64.decode(publicKey);

    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory      = KeyFactory.getInstance(KEY_ALGORITHM);
    PublicKey publicK          = keyFactory.generatePublic(keySpec);
    Signature signature        = Signature.getInstance(SIGNATURE_ALGORITHM);

    signature.initVerify(publicK);
    signature.update(data.getBytes(ENCODING));

    return signature.verify(Base64.decode(sign));
} catch (Exception e) {
    throw e;
}
}

/**
 * private-key encryption
 * @param dataStr Original data
 * @param privateKey Private key
 * @return Encrypted data
 * @throws Exception
 */
static String encryptByPrivateKey(String dataStr, String privateKey) throws Exception {
    byte[] data     = dataStr.getBytes(ENCODING);
    byte[] keyBytes = Base64.decode(privateKey);

    PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    Key privateK          = keyFactory.generatePrivate(pkcs8KeySpec);
    Cipher cipher         = Cipher.getInstance(keyFactory.getAlgorithm());

    cipher.init(Cipher.ENCRYPT_MODE, privateK);
    int inputLen = data.length;
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    int offSet = 0;
    byte[] cache;
    int i = 0;
    while (inputLen - offSet > 0) {
        if (inputLen - offSet > MAX_ENCRYPT_BLOCK) {
            cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
        } else {
            cache = cipher.doFinal(data, offSet, inputLen - offSet);
        }
        out.write(cache, 0, cache.length);
        i++;
        offSet = i * MAX_ENCRYPT_BLOCK;
    }
    byte[] encryptedData = out.toByteArray();
    out.close();
    return Base64.encodeToString(encryptedData);
}

/**
 * Public key decryption
 * @param encryptedDataStr Encrypted data
 * @param publicKey Public Key
 * @return Decrypted data
 * @throws Exception
 */
static String decryptByPublicKey(String encryptedDataStr, String publicKey) throws Exception {
    byte[] encryptedData = Base64.decode(encryptedDataStr);
    byte[] keyBytes      = Base64.decode(publicKey);

    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    Key publicK = keyFactory.generatePublic(x509KeySpec);
    Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());

    cipher.init(Cipher.DECRYPT_MODE, publicK);
    int inputLen = encryptedData.length;
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    int offSet = 0;
    byte[] cache;
    int i = 0;
    while (inputLen - offSet > 0) {
        if (inputLen - offSet > MAX_DECRYPT_BLOCK) {
            cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
        } else {
            cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
        }
        out.write(cache, 0, cache.length);
        i++;
        offSet = i * MAX_DECRYPT_BLOCK;
    }
    byte[] decryptedData = out.toByteArray();
    out.close();
    return new String(decryptedData, ENCODING);
}

/**
 * Public key encryption
 * @param dataStr Original data
 * @param publicKey Public Key
 * @return Encrypted data
 * @throws Exception
 */
static String encryptByPublicKey(String dataStr, String publicKey) throws Exception {
    byte[] data     = dataStr.getBytes(ENCODING);
    byte[] keyBytes = Base64.decode(publicKey);

    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    Key publicK           = keyFactory.generatePublic(x509KeySpec);
    Cipher cipher         = Cipher.getInstance(keyFactory.getAlgorithm());

    cipher.init(Cipher.ENCRYPT_MODE, publicK);
    int inputLen = data.length;
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    int offSet = 0;
    byte[] cache;
    int i = 0;
    while (inputLen - offSet > 0) {
        if (inputLen - offSet > MAX_ENCRYPT_BLOCK) {
            cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
        } else {
            cache = cipher.doFinal(data, offSet, inputLen - offSet);
        }
        out.write(cache, 0, cache.length);
        i++;
        offSet = i * MAX_ENCRYPT_BLOCK;
    }
    byte[] encryptedData = out.toByteArray();
    out.close();
    return Base64.encodeToString(encryptedData);
}

/**
 * Private key decryption
 * @param encryptedDataStr Encrypted data
 * @param privateKey Private key
 * @return Decrypted data
 * @throws Exception
 */
static String decryptByPrivateKey(String encryptedDataStr, String privateKey) throws Exception {
    byte[] encryptedData = Base64.decode(encryptedDataStr);
    byte[] keyBytes      = Base64.decode(privateKey);

    PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
    Key privateK          = keyFactory.generatePrivate(pkcs8KeySpec);
    Cipher cipher         = Cipher.getInstance(keyFactory.getAlgorithm());

    cipher.init(Cipher.DECRYPT_MODE, privateK);
    int inputLen = encryptedData.length;
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    int offSet = 0;
    byte[] cache;
    int i = 0;
    while (inputLen - offSet > 0) {
        if (inputLen - offSet > MAX_DECRYPT_BLOCK) {
            cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
        } else {
            cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
        }
        out.write(cache, 0, cache.length);
        i++;
        offSet = i * MAX_DECRYPT_BLOCK;
    }
    byte[] decryptedData = out.toByteArray();
    out.close();
    return new String(decryptedData, ENCODING);
}
/// ...
```

```php [PHP]
// ...
/**
 * Private key signing
 * @param string $dataStr Data String
 * @param string $privateKey Private key
 * @return string
 */
public static function sign($dataStr, $privateKey)
{
    $dataStr = self::str2utf8($dataStr);
    $privateKeyId = openssl_get_privatekey($privateKey);
    openssl_sign($dataStr, $sign, $privateKeyId, self::SIGNATURE_ALGORITHM);
    if (PHP_VERSION_ID < 80000) {
        openssl_free_key($privateKeyId);
    }
    return base64_encode($sign);
}

/**
 * Public key verification
 * @param string $dataStr Add signature to the original data string
 * @param string $publicKey Public key
 * @param string $sign Signature
 * @return bool
 */
public static function verifySign($dataStr, $publicKey, $sign)
{
    $dataStr     = self::str2utf8($dataStr);
    $publicKeyId = openssl_get_publickey($publicKey);
    return (boolean) openssl_verify($dataStr, base64_decode($sign), $publicKeyId, self::SIGNATURE_ALGORITHM);
}

/**
 * private-key encryption
 * @param string $dataStr Add signature to the original data string
 * @param string $privateKey Private key
 * @return string
 */
public static function encryptByPrivateKey($dataStr, $privateKey)
{
    $dataStr      = self::str2utf8($dataStr);
    $privateKeyId = openssl_get_privatekey($privateKey);
    $data         = "";

    $dataArray = str_split($dataStr, self::PRIVATE_KEY_BITS / 8 - 11);
    foreach ($dataArray as $value) {
        openssl_private_encrypt($value,$encryptedTemp, $privateKeyId,self::EN_DE_ALGORITHM);
        $data .= $encryptedTemp;
    }
    if (PHP_VERSION_ID < 80000) {
        openssl_free_key($privateKeyId);
    }
    return base64_encode($data);
}

/**
 * Public key decryption
 * @param string $encryptData Encrypted data string
 * @param string $publicKey Publci key
 * @return string
 */
public static function decryptByPublicKey($encryptData, $publicKey) {
    $decrypted   = "";
    $decodeStr   = base64_decode($encryptData);
    $publicKeyId = openssl_get_publickey($publicKey);

    $enArray = str_split($decodeStr, self::PRIVATE_KEY_BITS / 8);

    foreach ($enArray as $value) {
        openssl_public_decrypt($value,$decryptedTemp, $publicKeyId,self::EN_DE_ALGORITHM);
        $decrypted .= $decryptedTemp;
    }
    if (PHP_VERSION_ID < 80000) {
        openssl_free_key($publicKeyId);
    }
    return $decrypted;
}

/**
 * Public key encryption
 * @param string $dataStr Add signature to the original data string
 * @param string $publicKey Public key
 * @return string
 */
public static function encryptByPublicKey($dataStr, $publicKey)
{
    $dataStr     = self::str2utf8($dataStr);
    $publicKeyId = openssl_get_publickey($publicKey);
    $data        = "";

    $dataArray = str_split($dataStr, self::PRIVATE_KEY_BITS / 8 - 11);
    foreach ($dataArray as $value) {
        openssl_public_encrypt($value,$encryptedTemp, $publicKeyId,self::EN_DE_ALGORITHM);
        $data .= $encryptedTemp;
    }
    openssl_free_key($publicKeyId);
    return base64_encode($data);
}

/**
 * Private key decryption
 * @param string $encryptData Encrypted data string
 * @param string $private Private key
 * @return string
 */
public static function decryptByPrivateKey($encryptData, $private) {
    $decrypted    = "";
    $decodeStr    = base64_decode($encryptData);
    $privateKeyId = openssl_get_privatekey($private);

    $enArray = str_split($decodeStr, self::PRIVATE_KEY_BITS / 8);

    foreach ($enArray as $value) {
        openssl_private_decrypt($value,$decryptedTemp, $privateKeyId,self::EN_DE_ALGORITHM);
        $decrypted .= $decryptedTemp;
    }
    openssl_free_key($privateKeyId);
    return $decrypted;
}
// ...
```

:::